// RFM69 DHT node sketch
//
// This node talks to the MQTT-Gateway and will:
// - send sensor data periodically and on-demand
// - receive commands from the gateway to control actuators
// - receive commands from the gateway to change settings
//
// Several nodes can operate within a single network; each have a unique node ID.
// On startup the node operates with default values, set on compilation.
//
// Hardware used is a 3.3 Volt 8MHz arduino Pro; this is easier to interface to RFM69 
//
// A DHT-11 is used for temperature & humidity measurements, other sensors and outputs can be added easily.
//
// Message format is: nodeID/deviceID/command/integer/float/string
//
// Depending on the type of data (integer, float or string) one of the payload variables is used
// Command = 0 means write a value in the node, cmd = 1 means read a value 
//
// Current defined devices are:
//
//	0	  uptime:			  read uptime node in minutes
//	1	  node:			    read/set transmission interval in seconds, 0 means no periodic transmission
//	2	  RSSI:			    read radio signal strength
//	3	  Version:		  read version node software
//	4	  Voltage:		  read input voltage
//	5	  ACK:			    read/set acknowledge message after a 'set' request
//	9   retry:			  read number of retransmissions needed in radiolink
//  32  Red LED:      read/set red LED
//  33  Green LED:    read/set green LED
//  34  Blue LED:     read/set blue LED
//  35  RGB LED:      set only rgb LED. read will send 32,33,34
//	40	Movement:     read PIR
//  41-45 OW-switch   read onewire switch
//	48	temperature:	read temperature
//	49	humidity:		  read humidity
//  51-55 OW-temp     read onewire temperature values
//  56  Watt
//  57  KWH
//  64  light:        read light sensor
//	90	error:			  tx only: error message if no wireless connection (generated by gateway)
//	92	error:			  tx only: device not supported
//	99	wakeup:			  tx only: first message sent on node startup
//
//	A debug mode is included which outputs messages on the serial output
//
//	RFM69 Library by Felix Rusu - felix@lowpowerlab.com
//	Get the RFM69 library at: https://github.com/LowPowerLab/
//
//	version 1.7 by Computourist@gmail.com december 2014
//	version 2.0 increased payload size; implemented node uptime; standard device type convention; error handling .
//	version 2.1 removed device 8; changed handling of device 40; compatible with gateway V2.2	; march 2015
//	version 2.2 fixed bug in function TXradio that prevented retransmission of radio packets ; oct 2015

#include <RFM69.h>
#include <SPI.h>
#include <DHT.h>

//
// CONFIGURATION PARAMETERS
//
#define NODEID 3 					// unique node ID within the closed network
#define GATEWAYID 1					// node ID of the Gateway is always 1
#define NETWORKID 100					// network ID of the network
#define ENCRYPTKEY "xxxxxxxxxxxxxxxx" 			// 16-char encryption key; same as on Gateway!
#define DEBUG						// uncomment for debugging
#define VERSION "Roomnode V1.0"				// this value can be queried as device 3

//Enable sensors
#define LEDENABLE
#define PIRENABLE
#define DHTENABLE
#define LIGHTENABLE
#define OWENABLE
//#define OWSW1ENABLE
//#define OWSW2ENABLE
//#define OWSW3ENABLE
//#define OWSW4ENABLE
//#define OWSW5ENABLE
#define OWTEMP1ENABLE
//#define OWTEMP2ENABLE
//#define OWTEMP3ENABLE
//#define OWTEMP4ENABLE
//#define OWTEMP5ENABLE
//#define PULSEENABLE

//Sensorsettings
#define OWSW1ADR {0x01, 0x7D, 0x5C, 0x86, 0x08, 0x00, 0x00, 0xAE}
#define OWSW2ADR { 0x01, 0x1B, 0x66, 0x87, 0x08, 0x00, 0x00, 0x69 }
#define OWSW3ADR 
#define OWSW4ADR 
#define OWSW5ADR 
#define PULSE_FACTOR 1000
#define MAX_WATT 10000

// Wireless settings	Match frequency to the hardware version of the radio
//#define FREQUENCY RF69_433MHZ
#define FREQUENCY RF69_868MHZ
//#define FREQUENCY RF69_915MHZ

#define IS_RFM69HW 					// uncomment only for RFM69HW! 
#define ACK_TIME 50 					// max # of ms to wait for an ack

// settings
#define OWPIN 4           // OneWire data pin
#define DHTPIN 3					// DHT data connection
#define DHTTYPE DHT22     // type of sensor
#define DHTTMPCORRECTION -1
#define SENSORPIN 7       // Pin for extra sensor
#define PIRPIN 8          // PIR data pin
#define RLEDPIN 9
#define GLEDPIN 5
#define BLEDPIN 6
#define LIGHTPIN A0
#define SERIAL_BAUD 115200
#define HOLDOFF 2000					// blocking period between button messages

//
//	STARTUP DEFAULTS
//
long 	TXinterval = 60;				// periodic transmission interval in seconds


//
//	VARIABLES
//
long	lastPeriod = -1;				// timestamp last transmission
long	lastMinute = -1;				// timestamp last minute
long	upTime = 0;					// uptime in minutes
int	signalStrength;					// radio signal strength
bool	setAck = true;					// send ACK message on 'SET' request
bool	send0, send1, send2, send3, send4;
bool	send5, send9, send92;
bool	promiscuousMode = false; 			// only listen to nodes within the closed network
bool 	wakeUp = true;					// wakeup flag
bool	msgBlock = false;				// flag to hold button messages to prevent overload
bool	retx = true; 					// flag to signal retransmission
int	numtx;							// number of retransmissions
#ifdef LEDENABLE
int LEDRState;
int LEDGState;
int LEDBState;
long LEDState;
bool  send32, send33, send34, send35;
#endif
#ifdef PIRENABLE
bool  ackPIR = true;          // flag for message on PIR trigger
bool  send40;
int  curPIR = LOW;        // current PIR state
int  lastPIR = LOW;       // last PIR state
long  lastPIRPress = -1;        // timestamp last PIRCHANGE
#endif
#ifdef DHTENABLE
float  hum, temp;          // humidity, temperature
bool  send48, send49;
DHT dht(DHTPIN, DHTTYPE, 3);      // initialise temp/humidity sensor for 3.3 Volt arduino
float dhttmpcor = DHTTMPCORRECTION;
#endif
#ifdef LIGHTENABLE
int  LightState;          // temperature
bool  send64;
#endif
#ifdef OWENABLE
#include <OneWire.h>
#include <DallasTemperature.h>
OneWire oneWire(OWPIN);
DallasTemperature sensors(&oneWire);
bool  ackSwitch = true;       // flag for message on OneWire switch
byte  addr[8];
#endif
#ifdef OWSW1ENABLE
int  ow1swState;          // temperature
bool  send41;
bool  curOW1 = true;        // current OW1 state
bool  lastOW1 = true;       // last OW1 state
byte adrSW1[8] = {0x01, 0x7D, 0x5C, 0x86, 0x08, 0x00, 0x00, 0xAE};
#endif
#ifdef OWSW2ENABLE
int  ow2swState;          // temperature
bool  send42;
bool  curOW2 = true;        // current OW2 state
bool  lastOW2 = true;       // last OW2 state
DeviceAddress adrSW2 = OWSW2ADR;
#endif
#ifdef OWSW3ENABLE
int  ow3swState;          // temperature
bool  send43;
bool  curOW3 = true;        // current OW3 state
bool  lastOW3 = true;       // last OW3 state
DeviceAddress adrSW3 = OWSW3ADR;
#endif
#ifdef OWSW4ENABLE
int  ow4swState;          // temperature
bool  send44;
bool  curOW4 = true;        // current OW4 state
bool  lastOW4 = true;       // last OW4 state
DeviceAddress adrSW4 = OWSW4ADR;
#endif
#ifdef OWSW5ENABLE
int  ow5swState;          // temperature
bool  send45;
bool  curOW5 = true;        // current OW5 state
bool  lastOW5 = true;       // last OW5 state
DeviceAddress adrSW5 = OWSW5ADR;
#endif
#ifdef OWTEMP1ENABLE
float  ow1tempState;          // temperature
bool  send51;
#endif
#ifdef OWTEMP2ENABLE
float  ow2tempState;          // temperature
bool  send52;
#endif
#ifdef OWTEMP3ENABLE
float  ow3tempState;          // temperature
bool  send53;
#endif
#ifdef OWTEMP4ENABLE
float  ow4tempState;          // temperature
bool  send54;
#endif
#ifdef OWTEMP5ENABLE
float  ow5tempState;          // temperature
bool  send55;
#endif
#ifdef PULSEENABLE
double ppwh = ((double)PULSE_FACTOR)/1000;
volatile unsigned long pulseCount = 0;   
volatile unsigned long lastBlink = 0;
volatile unsigned long watt = 0;
unsigned long oldPulseCount = 0;   
unsigned long oldWatt = 0;
double oldKwh;
unsigned long lastSend;
#endif



typedef struct {					// Radio packet format
int	nodeID;						// node identifier
int	devID;						// device identifier 
int	cmd;						// read or write
long	intVal;						// integer payload
float	fltVal;						// floating payload
char	payLoad[32];					// string payload
} Message;

Message mes;
RFM69 radio;

//
//=====================		SETUP	========================================
//
void setup() {
#ifdef DEBUG
	Serial.begin(SERIAL_BAUD);
  delay(100);
#endif
#ifdef LEDENABLE
pinMode(RLEDPIN, OUTPUT);
pinMode(GLEDPIN, OUTPUT);
pinMode(BLEDPIN, OUTPUT);
LEDRState = 255;
LEDGState = 125;
LEDBState = 0;
analogWrite(RLEDPIN, LEDRState);
analogWrite(GLEDPIN, LEDGState);
analogWrite(BLEDPIN, LEDBState);
delay(100);
#endif
#ifdef PIRENABLE
pinMode(PIRPIN, INPUT);
delay(100);
#endif
#ifdef DHTENABLE
dht.begin();						// initialise temp/hum sensor
delay(100);
#endif
#ifdef OWENABLE
sensors.begin(); // Onewire: Start up the library
delay(100);
#endif
#ifdef LIGHTENABLE
pinMode(LIGHTPIN, INPUT);
analogReference(DEFAULT);
delay(100);
#endif
radio.initialize(FREQUENCY,NODEID,NETWORKID);		// initialise radio 
delay(100);
#ifdef IS_RFM69HW
radio.setHighPower(); 					// only for RFM69HW!
delay(100);
#endif
radio.encrypt(ENCRYPTKEY);				// set radio encryption	
radio.promiscuous(promiscuousMode);			// only listen to closed network
wakeUp = true;						// send wakeup message
delay(100);
#ifdef DEBUG
	Serial.print("Node Software Version ");
	Serial.println(VERSION);
	Serial.print("\nTransmitting at ");
	Serial.print(FREQUENCY==RF69_433MHZ ? 433 : FREQUENCY==RF69_868MHZ ? 868 : 915);
	Serial.println(" Mhz...");
  delay(100);
#endif
#ifdef LEDENABLE
LEDRState = 0;
LEDGState = 0;
LEDBState = 0;
analogWrite(RLEDPIN, LEDRState);
analogWrite(GLEDPIN, LEDGState);
analogWrite(BLEDPIN, LEDBState);
delay(500);
analogWrite(RLEDPIN, 255);
delay(50);
analogWrite(RLEDPIN, 0);
delay(200);
analogWrite(RLEDPIN, 255);
delay(50);
analogWrite(RLEDPIN, 0);
delay(200);
analogWrite(RLEDPIN, 255);
delay(50);
analogWrite(RLEDPIN, 0);
#endif
}	// end setup

//
//
//====================		MAIN	========================================
//
void loop() {
// RECEIVE radio input
//
if (receiveData()) parseCmd();				// receive and parse any radio input

// DETECT INPUT CHANGE
//
#ifdef PIRENABLE
curPIR = digitalRead(PIRPIN);
msgBlock = ((millis() - lastPIRPress) < HOLDOFF);    // hold-off time for additional button messages
if (!msgBlock &&  (curPIR != lastPIR)) {      // input changed ?
  delay(5);
  lastPIRPress = millis();              // take timestamp
  send40 = true;                    // set button message flag
lastPIR = curPIR;
}
#endif

#ifdef OWENABLE
sensors.requestTemperatures(); // Send command to get temperatures
/*if ( !oneWire.search(addr)) {
  Serial.println("No more addresses.");
  Serial.println();
  oneWire.reset_search();
}

if(addr == adrSW1) {
  Serial.println("  Chip = DS18S20");  // or old DS1820
}

for (int i = 0;  i < 8; i++)
{
  Serial.print(addr[i], HEX);
  Serial.write(' ');
  Serial.println(adrSW1[i]);
  if( addr[i] != adrSW1[i] ) 
  {
    Serial.println("not equal");
    //set your boolean flag here
    break;
  }
}
  
delay(50);*/
#endif

// UPTIME 
//

if (lastMinute != (millis()/60000)) {			// another minute passed ?
	lastMinute = millis()/60000;
	upTime++;
	}

// PERIODIC TRANSMISSION
//

if (TXinterval > 0)
{
int currPeriod = millis()/(TXinterval*1000);
if (currPeriod != lastPeriod) {				// interval elapsed ?
	lastPeriod = currPeriod;
	
// list of sensordata to be sent periodically..
// remove comment to include parameter in transmission
 
  send0 = true;         // send uptime
	send1 = true;					// send transmission interval
	send2 = true; 				// signal strength
  send3 = true;         // send firmware version
  send4 = true;					// voltage level
  send5 = true;         //  send ack state
	send9 = true;					// number of retransmissions
  #ifdef LEDENABLE
  send32 = true;        // send RED LED
  send33 = true;        // send GREEN LED
  send34 = true;        // send BLUE LED
  #endif
  #ifdef PIRENABLE
  send40 = true;        // send PIR
  #endif
  #ifdef OWSW1ENABLE
  send41 = true;        // send OW switch 1
  #endif
  #ifdef OWSW2ENABLE
  send42 = true;        // send OW switch 2
  #endif
  #ifdef OWSW3ENABLE
  send43 = true;        // send OW switch 3
  #endif
  #ifdef OWSW4ENABLE
  send44 = true;        // send OW switch 4
  #endif
  #ifdef OWSW5ENABLE
  send45 = true;        // send OW switch 5
  #endif
  #ifdef DHTENABLE
  send48 = true;				// send temperature
	send49 = true;				// send humidity
  #endif
  #ifdef LIGHTENABLE
  send64 = true;        // send light
  #endif
  #ifdef OWTEMP1ENABLE
  send51 = true;        // send OW temp 1
  #endif
  #ifdef OWTEMP2ENABLE
  send52 = true;        // send OW temp 2
  #endif
  #ifdef OWTEMP3ENABLE
  send53 = true;        // send OW temp 3
  #endif
  #ifdef OWTEMP4ENABLE
  send54 = true;        // send OW temp 4
  #endif
  #ifdef OWTEMP5ENABLE
  send55 = true;        // send OW temp 5
  #endif
	}
}

// SEND RADIO PACKETS
//

sendMsg();						// send any radio messages 

}		// end loop

//
//
//=====================		FUNCTIONS	==========================================

//
//========		RECEIVEDATA : receive data from gateway over radio
//

bool receiveData() {
bool validPacket = false;
if (radio.receiveDone())				// check for received packets
{
if (radio.DATALEN != sizeof(mes))			// wrong message size means trouble
#ifdef DEBUG
	Serial.println("invalid message structure..")
#endif
;
else
{
	mes = *(Message*)radio.DATA;
	validPacket = true;				// YES, we have a packet !
	signalStrength = radio.RSSI;
#ifdef DEBUG
	Serial.print(mes.devID);
	Serial.print(", ");
	Serial.print(mes.cmd);
	Serial.print(", ");
	Serial.print(mes.intVal);
	Serial.print(", ");
	Serial.print(mes.fltVal);
	Serial.print(", RSSI= ");
	Serial.println(radio.RSSI);
	Serial.print("Node: ");
	Serial.println(mes.nodeID);
#endif	
}
}
if (radio.ACKRequested()) radio.sendACK();		// respond to any ACK request
return validPacket;					// return code indicates packet received
}		// end recieveData

//
//
//==============		PARSECMD: analyse messages and execute commands received from gateway
//

void parseCmd() {					// parse messages received from the gateway
send0 = false;						// initialise all send triggers
send1 = false;
send2 = false;
send3 = false; 
send4 = false;
send5 = false;
send9 = false;
#ifdef LEDENABLE
send32 = false;
send33 = false;
send34 = false;
send35 = false;
#endif
#ifdef PIRENABLE
send40 = false;
#endif
#ifdef OWSW1ENABLE
send41 = false;
#endif
#ifdef OWSW2ENABLE
send42 = false;
#endif
#ifdef OWSW3ENABLE
send43 = false;
#endif
#ifdef OWSW4ENABLE
send44 = false;
#endif
#ifdef OWSW5ENABLE
send45 = false;
#endif
#ifdef DHTENABLE
send48 = false;
send49 = false;
#endif
#ifdef LIGHTENABLE
send64 = false;
#endif
#ifdef OQTEMP1ENABLE
send51 = false;
#endif
#ifdef OQTEMP2ENABLE
send52 = false;
#endif
#ifdef OQTEMP3ENABLE
send53 = false;
#endif
#ifdef OQTEMP4ENABLE
send54 = false;
#endif
#ifdef OQTEMP5ENABLE
send55 = false;
#endif

switch (mes.devID)					// devID indicates device (sensor) type
{
case (0):						// uptime
if (mes.cmd == 1) send0 = true;
break;
case (1):						// polling interval in seconds
if (mes.cmd == 0) {					// cmd == 0 means write a value
	TXinterval = mes.intVal;			// change interval to radio packet value
	if (TXinterval <10 && TXinterval !=0) TXinterval = 10;	// minimum interval is 10 seconds
	if (setAck) send1 = true;			// send message if required
#ifdef DEBUG
	Serial.print("Setting interval to ");
	Serial.print(TXinterval);
	Serial.println(" seconds");
#endif
}
else send1 = true;					// cmd == 1 is a read request, so send polling interval 
break;
case (2): 						// signal strength
if (mes.cmd == 1) send2 = true;
break;
case (3): 						// software version
if (mes.cmd == 1) send3 = true;
break;
case (4): 						// battery level
if (mes.cmd == 1) send4 = true;
break;
case (5): 						// set ack status
if (mes.cmd == 0) {
	if (mes.intVal == 0) setAck = false;
	if (mes.intVal == 1) setAck = true;
	if (setAck) send5 = true;			// acknowledge message ?
}
else send5 = true;					// read request means schedule a message
break;
case (9):						// retransmissions
if (mes.cmd == 1) send9 = true;
break;
#ifdef LEDENABLE
case (32):            // RLED
if (mes.cmd == 0) {          // cmd == 0 means write
  LEDRState = mes.intVal;
  analogWrite(RLEDPIN, LEDRState);
  if (setAck) send32 = true;      // acknowledge message ?
#ifdef DEBUG  
  Serial.print("Set Red LED State to: ");
  Serial.println(LEDRState);
#endif
}
else send32 = true;         // cmd == 1 means read
break;
case (33):            // GLED
if (mes.cmd == 0) {          // cmd == 0 means write
  LEDGState = mes.intVal;
  analogWrite(GLEDPIN, LEDGState);
  if (setAck) send33 = true;      // acknowledge message ?
#ifdef DEBUG  
  Serial.print("Set Green LED State to: ");
  Serial.println(LEDGState);
#endif
}
else send33 = true;         // cmd == 1 means read
break;
case (34):            // BLED
if (mes.cmd == 0) {          // cmd == 0 means write{
  LEDBState = mes.intVal;
  analogWrite(BLEDPIN, LEDBState);
  if (setAck) send34 = true;      // acknowledge message ?
#ifdef DEBUG  
  Serial.print("Set Blue LED State to: ");
  Serial.println(LEDBState);
#endif
}
else send34 = true;         // cmd == 1 means read
break;
case (35):            // BLED
if (mes.cmd == 0) {          // cmd == 0 means write{
  LEDState = mes.intVal;
  LEDRState = LEDState/1000000;
  LEDGState = (LEDState/1000)-(LEDRState*1000);
  LEDBState = LEDState-(LEDRState*1000000)-(LEDGState*1000);
  analogWrite(RLEDPIN, LEDRState);
  analogWrite(GLEDPIN, LEDGState);
  analogWrite(BLEDPIN, LEDBState);
  if (setAck){
    send32 = true;      // acknowledge message ?
    send33 = true;      // acknowledge message ?
    send34 = true;      // acknowledge message ?
  }
#ifdef DEBUG  
  Serial.print("Set RGB State: ");
  Serial.println(LEDState);
  Serial.print("Set Red LED State to: ");
  Serial.println(LEDRState);
  Serial.print("Set Green LED State to: ");
  Serial.println(LEDGState);
  Serial.print("Set Blue LED State to: ");
  Serial.println(LEDBState);
#endif
}
else {
  send32 = true;
  send33 = true;
  send34 = true;         // cmd == 1 means read
}
break;
#endif
#ifdef PIRENABLE
case (40):						// binary input
if (mes.cmd == 1) send40 = true;
break;
#endif
#ifdef OWSW1ENABLE
case (41):            // binary input
if (mes.cmd == 1) send41 = true;
break;
#endif
#ifdef OWSW2ENABLE
case (42):            // binary input
if (mes.cmd == 1) send42 = true;
break;
#endif
#ifdef OWSW3ENABLE
case (43):            // binary input
if (mes.cmd == 1) send43 = true;
break;
#endif
#ifdef OWSW4ENABLE
case (44):            // binary input
if (mes.cmd == 1) send44 = true;
break;
#endif
#ifdef OWSW5ENABLE
case (45):            // binary input
if (mes.cmd == 1) send45 = true;
break;
#endif
#ifdef DHTENABLE
case (48):						// temperature
if (mes.cmd == 1) send48 = true;
break;
case (49):						// humidity
if (mes.cmd == 1) send49 = true;
break;
#endif
#ifdef LIGHTENABLE
case (64):            // temperature
if (mes.cmd == 1) send64 = true;
break;
#endif
#ifdef OWTEMP1ENABLE
case (51):            // humidity
if (mes.cmd == 1) send51 = true;
break;
#endif
#ifdef OWTEMP2ENABLE
case (52):            // temperature
if (mes.cmd == 1) send52 = true;
break;
#endif
#ifdef OWTEMP3ENABLE
case (53):            // humidity
if (mes.cmd == 1) send53 = true;
break;
#endif
#ifdef OWTEMP4ENABLE
case (54):            // temperature
if (mes.cmd == 1) send54 = true;
break;
#endif
#ifdef OWTEMP5ENABLE
case (55):            // OWTEMP5
if (mes.cmd == 1) send55 = true;
break;
#endif
default: send92 = true;					// no valid device parsed
}
}	// end parseCmd

//
//
//======================		SENDMSG: sends messages that are flagged for transmission
//

void sendMsg() {					// prepares values to be transmitted
bool tx = false; 					// transmission flag
mes.nodeID=NODEID;
mes.intVal = 0;
mes.fltVal = 0;
mes.cmd = 0;						// '0' means no action needed in gateway
int i;
for ( i = 0; i < sizeof(VERSION); i++){
mes.payLoad[i] = VERSION[i];	}
mes.payLoad[i] = '\0';					// software version in payload string

if (wakeUp) {						// send wakeUp call 
	mes.devID = 99;	
	wakeUp = false;					// reset transmission flag for this message
	txRadio();					// transmit
}
if (send0) {
	mes.devID = 0;
	mes.intVal = upTime;				// minutes uptime
	send0 = false;
	txRadio();
}
if (send1) {						// transmission interval
	mes.devID = 1;
	mes.intVal = TXinterval;			// seconds (integer)
	send1 = false;
	txRadio();
}
if (send2) {
	mes.devID = 2;
	mes.intVal = signalStrength;			// signal strength (integer)
	send2 = false;
	txRadio();
}
if (send3) {						// node software version (string)
	mes.devID = 3;					// already stored in payload string
	send3 = false;
	txRadio();
}
if (send4) {						// measure voltage..
	mes.devID = 4;	
	long result;					// Read 1.1V reference against AVcc
	ADMUX = _BV(REFS0) | _BV(MUX3) | _BV(MUX2) | _BV(MUX1);
	delay(2);					// Wait for Vref to settle
	ADCSRA |= _BV(ADSC);				// Convert
	while (bit_is_set(ADCSRA,ADSC));
	result = ADCL;
	result |= ADCH<<8;
	result = 1126400L / result; 			// Back-calculate in mV
	mes.fltVal = float(result/1000.0);		// Voltage in Volt (float)
	txRadio();
	send4 = false;
}
if (send5) {						// Acknowledge on 'SET'
	mes.devID = 5;
	if (setAck) mes.intVal = 1; else mes.intVal = 0;// state (integer)
	send5 = false;
	txRadio();
}
if (send9) {						// number of retransmissions
	mes.devID = 9;
	mes.intVal = numtx;			// number (integer)
	send9 = false;
	txRadio();
}
#ifdef LEDENABLE
if (send32) {            // LED Red
  mes.devID = 32;
  mes.intVal = LEDRState;       // state (integer)
  send32 = false;
  txRadio();
}
if (send33) {            // LED Green
  mes.devID = 33;
  mes.intVal = LEDGState;       // state (integer)
  send33 = false;
  txRadio();
}
if (send34) {            // LED Blue
  mes.devID = 34;
  mes.intVal = LEDBState;       // state (integer)
  send34 = false;
  txRadio();
}
#endif
#ifdef PIRENABLE
if (send40) {            // Binary input read
  mes.devID = 40;
  if (curPIR == LOW) mes.intVal = 0;          // state (integer)
  send40 = false;
  txRadio();
}
#endif
#ifdef OWSW1ENABLE
if (send41) {            // Binary input read
  mes.devID = 41;
  if (curOW1 == LOW) mes.intVal = 1;          // state (integer)
  send41 = false;
  txRadio();
}
#endif
#ifdef OWSW2ENABLE
if (send42) {            // Binary input read
  mes.devID = 42;
  if (curOW2 == LOW) mes.intVal = 1;          // state (integer)
  send42 = false;
  txRadio();
}
#endif
#ifdef OWSW3ENABLE
if (send43) {            // Binary input read
  mes.devID = 43;
  if (curOW3 == LOW) mes.intVal = 1;          // state (integer)
  send43 = false;
  txRadio();
}
#endif
#ifdef OWSW4ENABLE
if (send44) {            // Binary input read
  mes.devID = 44;
  if (curOW4 == LOW) mes.intVal = 1;          // state (integer)
  send44 = false;
  txRadio();
}
#endif
#ifdef OWSW5ENABLE
if (send45) {            // Binary input read
  mes.devID = 45;
  if (curOW5 == LOW) mes.intVal = 1;          // state (integer)
  send45 = false;
  txRadio();
}
#endif
#ifdef DHTENABLE
if (send48) {            // Temperature
  mes.devID = 48;
  temp = dht.readTemperature() + dhttmpcor;
  mes.fltVal = temp;        // Degrees Celcius (float)
  send48 = false;
  txRadio();
}
if (send49) {           // Humidity
  mes.devID = 49;
  hum = dht.readHumidity();
  mes.fltVal = hum;       // Percentage (float)
  send49 = false;
  txRadio();
}
#endif
#ifdef LIGHTENABLE
if (send64) {            // Light
  mes.devID = 64;
  LightState = analogRead(LIGHTPIN);
  mes.intVal = LightState;        // Lightpin value
  send64 = false;
  txRadio();
}
#endif
#ifdef OWTEMP1ENABLE
if (send51) {            // Temperature
  mes.devID = 51;
  ow1tempState = sensors.getTempCByIndex(0);
  mes.fltVal = ow1tempState;        // Degrees Celcius (float)
  send51 = false;
  txRadio();
}
#endif
#ifdef OWTEMP2ENABLE
if (send52) {            // Temperature
  mes.devID = 52;
  ow2tempState = sensors.getTempCByIndex(2);
  mes.fltVal = ow2tempState;        // Degrees Celcius (float)
  send52 = false;
  txRadio();
}
#endif
#ifdef OWTEMP3ENABLE
if (send53) {            // Temperature
  mes.devID = 53;
  ow3tempState = sensors.getTempCByIndex(3);
  mes.fltVal = ow3tempState;        // Degrees Celcius (float)
  send53 = false;
  txRadio();
}
#endif
#ifdef OWTEMP4ENABLE
if (send54) {            // Temperature
  mes.devID = 54;
  ow4tempState = sensors.getTempCByIndex(4);
  mes.fltVal = ow4tempState;        // Degrees Celcius (float)
  send54 = false;
  txRadio();
}
#endif
#ifdef OWTEMP5ENABLE
if (send55) {            // Temperature
  mes.devID = 55;
  ow5tempState = sensors.getTempCByIndex(5);
  mes.fltVal = ow5tempState;        // Degrees Celcius (float)
  send55 = false;
  txRadio();
}
#endif
if (send92) {						// error message invalid device
	mes.intVal = mes.devID;
	mes.devID = 92;
        send92 = false;
	txRadio();
}

}
//
//
//=======================		TXRADIO
//

void txRadio()						// Transmits the 'mes'-struct to the gateway
{
retx = true;
int i = 0;

while (retx && i<6) {
if (radio.sendWithRetry(GATEWAYID, (const void*)(&mes), sizeof(mes),5)) {
	retx = false;
#ifdef DEBUG
	Serial.print(" message ");
	Serial.print(mes.devID);
	Serial.println(" sent...");
#endif
} else delay(500);
i++;
}
numtx = i;							// store number of retransmissions needed
#ifdef DEBUG
	if (retx) Serial.println("No connection...")
#endif
;}	// end txRadio






